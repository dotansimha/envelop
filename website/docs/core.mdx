---
title: '@envelop/core'
---

This is the core package for `envelop`, it comes with the execution pipeline wrapper, and some basic core plugins you can use for creating your initial Envelop instance.

### Built-in plugins

#### useSchema

This plugin is the simplest plugin for specifying your GraphQL schema. You can specify a schema created from any tool that emits `GraphQLSchema` object.

```ts
import { envelop, useSchema } from '@envelop/core'
import { parse, validate, execute, subscribe } from 'graphql'

const mySchema = buildSchema(/* ... */)

const getEnveloped = envelop({
  parse,
  validate,
  execute,
  subscribe,
  plugins: [
    useSchema(mySchema)
    // ... other plugins ...
  ]
})
```

#### useAsyncSchema

This plugin is the simplest plugin for specifying your GraphQL schema, but in an async way.

If you are using a framework that creates the schema in an async way, you can either use this plugin, or `await` for the schema and then use `useSchema`.

```ts
import { envelop, useAsyncSchema } from '@envelop/core'
import { parse, validate, execute, subscribe } from 'graphql'

const getSchema = async (): Promise<GraphQLSchema> => {
  // return schema when it's ready
}

const getEnveloped = envelop({
  parse,
  validate,
  execute,
  subscribe,
  plugins: [
    useAsyncSchema(getSchema())
    // ... other plugins ...
  ]
})
```

#### useErrorHandler

This plugin invokes a custom function with the every time execution encounters an error.

```ts
import { envelop, useErrorHandler } from '@envelop/core'
import { parse, validate, execute, subscribe } from 'graphql'

const getEnveloped = envelop({
  parse,
  validate,
  execute,
  subscribe,
  plugins: [
    useErrorHandler(error => {
      // This callback is called per each GraphQLError emitted during execution phase
    })
    // ... other plugins ...
  ]
})
```

> **Note:** The handler is invoked for each error. So an execution result with multiple errors will yield multiple calls.

#### useExtendContext

Easily extends the context with custom fields.

```ts
import { envelop, useExtendContext } from '@envelop/core'
import { parse, validate, execute, subscribe } from 'graphql'

const getEnveloped = envelop({
  parse,
  validate,
  execute,
  subscribe,
  plugins: [
    useExtendContext(async contextSoFar => {
      return {
        myCustomField: {
          /* ... */
        }
      }
    })
    // ... other plugins ...
  ]
})
```

#### useLogger

Logs parameters and information about the execution phases. You can easily plug in your custom logger.

```ts
import { envelop, useLogger } from '@envelop/core'
import { parse, validate, execute, subscribe } from 'graphql'

const getEnveloped = envelop({
  parse,
  validate,
  execute,
  subscribe,
  plugins: [
    useLogger({
      logFn: (eventName, args) => {
        // Event could be `execute-start` / `execute-end` / `subscribe-start` / `subscribe-end`
        // `args` will include the arguments passed to execute/subscribe (in case of "start" event) and additional result in case of "end" event.
      }
    })
    // ... other plugins ...
  ]
})
```

#### usePayloadFormatter

Allow you to format/modify the execution result payload before returning it to your consumer.

The second argument `executionArgs` provides additional information for your formatter. It consists of contextValue, variableValues, document, operationName, and other properties.

```ts
import { envelop, usePayloadFormatter } from '@envelop/core'
import { parse, validate, execute, subscribe } from 'graphql'

const getEnveloped = envelop({
  parse,
  validate,
  execute,
  subscribe,
  plugins: [
    usePayloadFormatter((result, executionArgs) => {
      // Return a modified result here,
      // Or `false`y value to keep it as-is.
    })
    // ... other plugins ...
  ]
})
```
